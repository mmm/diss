

\chapter{Quantum Algorithms}
\label{chap:quantumAlgorithms}
\index{Quantum Algorithms@\emph{Quantum Algorithms}}%

A quantum algorithm is a set of states and operations performed
with a quantum computer in order to arrive at an answer to a particular
specified problem.
There are no simple prescriptions for contructing a quantum algorithm.
There are no rules by which one can take an existing classical algorithm,
an algorithm developed to run on a classical computer, and construct
a corresponding quantum algorithm.  There are not even many tools or concepts
used in developing classical algorithms that carry over into the quantum
domain.

As discussed in Chapter \ref{chap:quantumComputation}, 
the advent of universal quantum gates
allows the representation of any computable function on a 
quantum computer.  However, the uniquely quantum operations that 
must be performed 
require a wider range of tricks to be used when developing
algorithms to be run on a quantum computer.

Despite the difficulty involved, there have been a few, seemingly
inspired, algorithms developed for a quantum computer.
In fact, the entire field essentially owes its existence to 
an algorithm developed by Peter Shor\cite{Shor:94,Shor:00}
to solve FACTORIZATION\footnote{The convention, originating in computer 
science, of YELLING the proper names of particular problems to be solved 
will be followed throughout this text.}, where the quantum version 
enjoys an \emph{exponential} speedup over the classical.  
The discovery of this algorithm has reduced the complexity class of 
this problem, a feat to which many in computer science aspire.

The following sections outline several aspects of quantum
algorithms.  A few existing algorithms are described, along
with the basic framework needed to determine their computational
complexity.  An approach to possible new algorithms is then 
discussed.

%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{Simple Quantum Algorithms}

%--------------------------------------------------------------------------------   
\subsection{Deutsch's Algorithm}

Deutsch\cite{Deutsch:?} gives a simple example of a problem that
can be solved faster on a quantum computer than its classical
counterpart.
Consider some black box that evaluates a function 
$f\colon\lbrace 0,1\rbrace\to\lbrace 0,1\rbrace$,
where each evaluation, for whatever reason, 
takes a long period of time to compute, say 24 hours.
The problem is to determine, as quickly as possible, 
information about the function
using only inputs and outputs of the black box.

The obvious approach is to simply set an input value,
then read the output value when the computation is done
(24 hours later).  Do this for all possible input values
($0$ or $1$), then, 48 hours later, you have all possible 
information about the function.

What if that time is not good enough?  Even if we are only 
interested in limited information about the function, 
such as is it \emph{constant} $\left( f(0) = f(1) \right)$ or
\emph{balanced} $\left( f(0) \ne f(1) \right)$, it would still
require full function evaluation (48 hours).

Is there a quicker way?  Yes, if there exists a quantum
black box that computes $f(x)$, then the problem can be solved
with a single function evaluation.  

First, insure reversability of the computation, even if the 
quantum black box itself is
not reversible, by constructing the unitary transformation
\begin{equation}
U_f\colon \ket{x}\ket{y} \to \ket{x}\ket{y\oplus f(x)},
\end{equation}
where the second bit is flipped if $f(x)=1$ and left alone
if $f(x)=0$.
Just as in the classical case, this computer can determine
if the function is constant or balanced with multiple evaluations
of $f(x)$.  Still taking 48 hours to arrive at an answer.

Because the black box is a quantum computer, it can accept
as an input a superposition of states $\ket{0}$ and $\ket{1}$.
If the second qubit is initially prepared in the state
$\frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right)$, then
\begin{equation}
\begin{split}
U_f\colon \ket{x}\otimes\frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right)
\quad\to&\quad\ket{x}\otimes\frac{1}{\sqrt{2}}\bigl(\ket{f(x)} - \ket{1\oplus f(x)}\bigr)\\
=&\quad\ket{x}\otimes(-1)^{f(x)}\frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right).
\end{split}
\end{equation}
Now, prepare the first qubit in the superposition 
$\frac{1}{\sqrt{2}}\left( \ket{0} + \ket{1} \right)$.
The black box now acts
\begin{multline}
U_f\colon \frac{1}{\sqrt{2}}\left( \ket{0} + \ket{1} \right)
        \otimes\frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right) \quad\to\\
        \frac{1}{\sqrt{2}}\bigl( (-1)^{f(0)}\ket{0} + (-1)^{f(1)}\ket{1} \bigr)
        \otimes\frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right).
\end{multline}
Now, we simply perform a measurement that projects the first qubit into
the basis
\begin{equation}
\ket{\pm} = \frac{1}{\sqrt{2}}\left( \ket{0} \pm \ket{1} \right),
\end{equation}
to learn, after a single function evaluation, that the function is
balanced if you measure $\ket{+}$, constant if $\ket{-}$.

So, here, the quantum computer gets an answer in around 24 hours, where
the classical one would require 48.  This speedup is attributed to
the concept of \emph{quantum parallelism}.  The quantum computer is not
limited to computing just a single $f(0)$ or $f(1)$ at a time, but in acting on
superpositions of states, it behaves as if there were a sort of 
parallelism in execution.  The computer essentially evaluates all inputs
at the same time, storing the information in correlations between the states
that make up the input and output registers.  This information
is only really available via specifically prepared measurements, but it is
there.  The output of the quantum computation does encode this ``global''
information about the function.

\subsubsection{The Deutsch--Jozsa Algorithm}

Of course, the simple function $\lbrace 0,1\rbrace\to\lbrace 0,1\rbrace$
discussed above is not particularly useful for anything other than
providing a simple example with which to exhibit a quantum algorithm.
However, the same principles apply to a more useful function
$f\colon\lbrace 0,1\rbrace^N\to\lbrace 0,1\rbrace$.
Again, construct the unitary operator
\begin{equation}
U_f\colon\ket{x}\ket{0}\to\ket{x}\ket{f(x)}.
\end{equation}
Then, via a Hadamard tranformation ({\it c.f.}, chapter
(\ref{chap:quantumComputation})), choose the input register to 
be in the state
\begin{equation}
\left[\frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right)\right]^N
= \frac{1}{2^{N/2}}\sum_{x=0}^{2^N-1}\ket{x}.
\end{equation}
A single function evaluation leaves 
\begin{equation}
    \frac{1}{2^{N/2}}\sum_{x=0}^{2^N-1}\ket{x}\ket{f(x)},
\end{equation}
which encodes ``global'' information about the function.
The trick is to now extract this information via specialized
measurements.

Consider the classical version of the above computation.
Depending on what sort of information we are trying to obtain
about the function, there are \emph{many}(!) function evaluations
required.  For $N\gg 1$, this quickly becomes intractable. 
The quantum case required only one.  For obvious reasons, this is 
considered ``massive quantum parallelism'' in the literature.

%--------------------------------------------------------------------------------   
\subsection{Simon's Algorithm}

In the last section it was shown how quantum algorithms can
exhibit a speedup over algorithms designed to run on a classical
computer.  How much faster can certain problems be solved?
Do the problems remain in the same complexity class ({\it c.f.},
chapter (\ref{chap:quantumComputation})), or like for Shor's 
algorithm, will the quantum algorithm change the actual 
complexity class of the problem?

Simon's algorithm\cite{Simon:97} 
is the simplest algorithm where the problem to
be solved is classically \emph{hard}, but can be computed in
polynomial time on a quantum computer.

Consider a function 
\begin{equation}
f\colon\lbrace 0,1\rbrace^n\to\lbrace 0,1\rbrace^n
\end{equation}
that is 2--to--1 and periodic when viewed as a map 
$\left(\Z_2\right)^n\to\left(\Z_2\right)^n$
(as opposed to $\Z_{2^n}\to\Z_{2^n}$).
\ie, If the period of $f$ is $a$, then
\begin{equation}
f(x) = f(x\oplus a).
\end{equation}
The problem is: given a quantum black box that evaluates such a function,
find its period.

This problem is classically hard\footnote{According to Shor\cite{Shor:00}},
because the function will need to be evaluated an exponentially large number
of times to find $a$.
\mmm{prove this}

The quantum solution to the problem starts with two zero registers
\begin{equation}
\ket{0}\ket{0}.
\end{equation}
Now prepare an equally weighted superposition of all $n$-bit strings
in the first register by using the Hadamaard transformation
\begin{equation}
\left(H\otimes\bf{1}\right)\ket{0}\ket{0} =
\left(\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^n-1}\ket{x}\right)\ket{0},
\end{equation}
and then query the oracle
\begin{equation}
U_f\colon\quad
\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^n-1}\ket{x}\ket{0}\quad\mapsto\quad
\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^n-1}\ket{x}\ket{f(x)}.
\end{equation}
Now, a measurement of the second register, let's say it is measured
to be in the state $\ket{c}$,
will collapse the first register into a superposition of all 
states $\ket{x_0}$ such that $f(x_0)=c$.  
For the function specified in this algorithm, 
there are two such values, $x_0$ and $x_0\oplus a$.
After the measurement of the second register, 
the first register then should look like 
\begin{equation}
\frac{1}{\sqrt{2}}\bigl(\ket{x_0}+\ket{x_0\oplus a}\bigr).
\end{equation}
Note that, at this point, a measurement of this first register tells
nothing about $a$.  However, taking another Hadamaard transformation 
(see equation \ref{e:generalHadamaard})
on the first register gives 
\begin{equation}
H \frac{1}{\sqrt{2}}\bigl(\ket{x_0}+\ket{x_0\oplus a}\bigr)=
\,\frac{1}{\sqrt{2^{n+1}}}\sum_{y=0}^{2^n-1}
\biggl[(-1)^{x_0\cdot y}+(-1)^{(x_0\oplus a)\cdot y}\biggr]\ket{y}.
\end{equation}
This is non--zero only for $a\cdot y=0$, and so the first register
can then be rewritten as
\begin{equation}
H \frac{1}{\sqrt{2}}\bigl(\ket{x_0}+\ket{x_0\oplus a}\bigr)
=\frac{1}{\sqrt{2^{n-1}}}\sum_{a\cdot y=0}
(-1)^{x_0\cdot y}\ket{y},
\end{equation}
which is just an equally weighted superposition of states
$\ket{y}$ such that $a\cdot y = 0$.
A measurement of the state in the first register will yield
any one of these states with equal likelihood.  Now, simply
repeat the entire algorithm $n$ times, each time obtaining
a particular value of $y$, say $y_i$ for trial $i$.
Then, solve the set of equations
\begin{equation}
\begin{split}
a\cdot y_1 =&\, 0\\
a\cdot y_2 =&\, 0\\
\vdots\quad&\\
a\cdot y_n =&\, 0\\
\end{split}
\end{equation}
for $a$.



\subsubsection{Testing Figures}

\mmm{testing}
\begin{figure}
\begin{center}
\begin{picture}(100,50)
    \put(10,0){\framebox(20,20){\bf{$H$}}}
    \put(10,30){\framebox(20,20){\bf{$H$}}}
    \put(70,30){\framebox(20,20){\bf{$H$}}}
    \put(40,0){\framebox(20,20){\bf{$U_f$}}}
    \put(-20,7){$\ket{x}$}
    \put(-20,37){$\ket{0}$}
    \put(110,7){$\ket{f(x)}$}
    \put(110,37){$\ket{0}$}
    \put(50,40){\circle*{4}}
    \path(0,10)(10,10)
    \path(30,10)(40,10)
    \path(60,10)(100,10)
    \path(0,40)(10,40)
    \path(30,40)(70,40)
    \path(90,40)(100,40)
    \path(50,20)(50,40)
\end{picture}
\caption{Deutsch's circuit}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\begin{picture}(50,60)
    \put(20,0){\framebox(20,20){\bf{$H$}}}
    \put(-20,7){$\ket{1}$}
    \put(-20,37){$\ket{0}$}
    \put(30,40){\circle*{4}}
    \path(0,10)(20,10)
    \path(40,10)(60,10)
    \path(0,40)(60,40)
    \path(30,20)(30,40)
\end{picture}
\caption{A quantum circuit applying a Hadamaard transformation to one of
two qubits with intersecting lines}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\begin{picture}(40,50)
    \put(20,40){\circle*{4}}
    \put(20,10){\circle{6}}
    \put(-20,7){$\ket{y}$}
    \put(-20,37){$\ket{x}$}
    \put(50,7){$\ket{y\oplus x}$}
    \put(50,37){$\ket{x}$}
    \path(0,10)(40,10)
    \path(0,40)(40,40)
    \path(20,7)(20,40)
\end{picture}
\caption{A controlled--\texttt{NOT} (\texttt{CNOT}) gate}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\begin{picture}(40,80)
    \put(20,70){\circle*{4}}
    \put(20,40){\circle*{4}}
    \put(20,10){\circle{6}}
    \put(-20,7){$\ket{z}$}
    \put(-20,37){$\ket{y}$}
    \put(-20,67){$\ket{x}$}
    \put(50,7){$\ket{z\oplus y\oplus x}$}
    \put(50,37){$\ket{y}$}
    \put(50,67){$\ket{x}$}
    \path(0,10)(40,10)
    \path(0,40)(40,40)
    \path(0,70)(40,70)
    \path(20,7)(20,70)
\end{picture}
\caption{A controlled--controlled--\texttt{NOT} (\texttt{CCNOT}) gate}
\end{center}
\end{figure}




%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{Prime Factorization}

Shor\dots

%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{Searching a Quantum Database}

Grover\cite{Grover:96}\dots did some stuff!

\subsubsection{classical search}
\subsubsection{reflections -n- stuff}

\mmm{Zalka says Grover is least time... use this to show Grover geodesic}
\mmm{introduce $n$ and $N$ up here}

\subsubsection{The Algorithm: Overview}

Grover's algorithm is briefly outlined in figure (\ref{fig:grover}).
\begin{figure}[h]
\shabox{
    \begin{minipage}{13cm}
        \begin{center}
        \textbf{Grover's Quantum Search Algorithm}
        \end{center}
        \begin{enumerate}
            \item First, start with an equally weighted superposition $\ket{S}$
            of all possible states.
            \item Next, repeat the following sequence $O(\sqrt{N})$ 
            times\footnote{exactly when to stop is important here.}:
            \begin{enumerate}
                \item Query the oracle.  Given any state, say $\ket{S}$, rotate 
                the phase of the desired state $\pi$ radians.
                \item Flip the state about the ``average'' by applying
                what Grover refers to as the diffusion transform, $D\ket{S}$.
            \end{enumerate}
            \item Finally, measure the resulting state.  This should be the
            desired state with probability of at least $\frac{1}{2}$.
        \end{enumerate}
    \end{minipage}
}
\caption{An overview of Grover's algorithm.}
\label{fig:grover}
\end{figure}
In the first step, an equally weighted superposition of all possible
states is, of course, obtained by hitting the $n$-dimensional zero 
register with the Hadamaard transformation
\begin{equation}
H\ket{0} = \frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^n-1}\ket{x} 
= \left[ \begin{matrix}
            \frac{1}{\sqrt{2^n}}\\
            \frac{1}{\sqrt{2^n}}\\
            \vdots\\
            \frac{1}{\sqrt{2^n}}
         \end{matrix} 
  \right].
\end{equation}
For simplicity, write $N=2^n$ so that
\begin{equation}
H\ket{0} = \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}\ket{x} 
= \left[ \begin{matrix}
            \frac{1}{\sqrt{N}}\\
            \frac{1}{\sqrt{N}}\\
            \vdots\\
            \frac{1}{\sqrt{N}}
         \end{matrix} 
  \right].
\end{equation}
The concept of an \emph{oracle} in step (2a) of figure (\ref{fig:grover}) 
can be confusing at first glance.  The idea is that there is some criteria
by which the search algorithm decides that the desired item has been found.
This is often thought of in terms of a function
\begin{equation}
f\colon\quad\lbrace\mbox{Search Domain}\rbrace\quad\mapsto\quad\lbrace Y,N\rbrace,
\end{equation}
that obtains a ``yes'' result for only a single particular input.








%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{Developing New Quantum Algorithms}

NP--Complete?
