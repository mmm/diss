
\chapter{Quantum Computation}
\label{chap:quantumComputation}
\index{Quantum Computation@\emph{Quantum Computation}}%

\subsubsection{General QC intro}

The search algorithm is
used to solve various other problems on a quantum
computer\cite{Durr/Hoyer:96,Grover:96b,Grover:97,Brassard/Hoyer/Tapp:97,
Terhal/Smolin:98,Brassard/Hoyer/Tapp:98,Cerf/Grover/Williams:98,Farhi/Gutmann:98}.

%%--------------------------------------------------------------------------------   
%%--------------------------------------------------------------------------------   
%\section{Information Theory}
%
%\subsubsection{Why do we care?}
%
%%--------------------------------------------------------------------------------   
%\subsection{Classical}
%
%\subsubsection{Entropy}
%\subsubsection{Information}
%\subsubsection{Coding}
%\subsubsection{Channel Capacity}
%
%%--------------------------------------------------------------------------------   
%\subsection{Quantum}
%
%\subsubsection{Entropy}
%\subsubsection{Information}
%\subsubsection{Measurement (POVMs and Optimal Measurements?)}
%\subsubsection{Entanglement}
%\subsubsection{Coding}
%\subsubsection{Dense Coding and Channel Capacity}
%\subsubsection{Teleportation}
%\subsubsection{Cloning}

%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{The Theory of Computation}


%--------------------------------------------------------------------------------   
\subsection{Classical Theory of Computation}
\label{ssec:classicalComp}

A classical computer can be viewed simply as a
system that evaluates a function of the following
form
\begin{equation}
f\colon\lbrace 0,1\rbrace^n \mapsto \lbrace 0,1\rbrace^m.
\end{equation}
This ``computer'' takes $n$ bits of input and uniquely
determines $m$ bits of output.
Since each of $m$ components of this function is just a 
simpler function to a single bit,
the basic operation of a classical computer is just 
\begin{equation}
f\colon\lbrace 0,1\rbrace^n \mapsto \lbrace 0,1\rbrace.
\end{equation}

These simple functions with one--bit outputs are commonly
referred to as \emph{decision problems}.\index{decision problems}
They encode the solution to a problem whose answer, based on
the input, requires only a YES or NO.  There are many such
decision problems that can be useful, but it is important to note
that there are also many apparently non--decision--type problems 
that can be transformed into decision problems.  
%Consider
%\mmm{examples}

To be evaluated on an actual computing device,
each of the basic functions must then be broken down into a 
sequence
of elementary logic operations.  These elementary operations
or {\sl logic gates}\index{logic gate} 
can then be implemented on various types 
of physical devices.

Consider a simple function
\begin{equation}
f\colon\lbrace 0,1\rbrace^n \mapsto \lbrace 0,1\rbrace.
\end{equation}
The claim is that the evaluation of this function can be
reduced to a sequence of elementary logical operations.
This can be seen by first considering the set of inputs
to the function.  Among the $2^n$ distinct inputs, distinguish
between those inputs $x$ for which the function evaluates to 
$f(x)=1$ and those for which $f(x)=0$.  
For each element
$x^{(i)}\in f^{-1}(1)$, define a {\sl characteristic function}
for this input as
\begin{equation}
f^{(i)}(x) = \begin{cases}
                1&x=x^{(i)}\\
                0&\text{otherwise}
             \end{cases}.
\end{equation}
This is the first step to a representation of the original function
in terms of simpler gates,  leaving an intermediate representation
of the function in terms of characteristic functions
\begin{equation}
f(x) = \bigvee_i f^{(i)}(x).
\end{equation}
The function $f$ is the logical OR ($\vee$) of the characteristic functions
for all inputs that evaluate to 1. \ie, all $x\in f^{-1}(1)$.
The way to interpret this representation is that $f(x)$ can evaluate
to 1 by either $x^{(1)}$ evaluating to 1 or $x^{(2)}$ evaluating to 1 
or\dots

The next step is to consider how the characteristic functions themselves
can be represented in terms of elementary logic gates.
The characteristic function for the input
\begin{equation}
x^{(i)} = 111\ldots1
\label{e:inputx}
\end{equation}
could be constructed as
\begin{equation}
f^{(i)} = x_1 \wedge x_2 \wedge \ldots\wedge x_n,
\end{equation}
the logical AND of all $n$ bits of the input $x^{(i)}$.
Each $x_j\in\lbrace 0,1\rbrace$ is the $j$--th bit of $x^{(i)}$.  
For this particular input (\ref{e:inputx}), all $x_j$'s are 1.
Any other input $x^{(i^\prime )}$ will have at least one zero bit.  
The characteristic function for this input is again the logical
AND of all bits, but the zero bits are flipped with the logical
NOT ($\neg$) operation.  For example, consider the input
\begin{equation}
x^{(i^\prime )} = 0110\ldots.
\end{equation}
The corresponding characteristic function would be 
\begin{equation}
f^{(i^\prime )}(x) = (\neg x_1 )\wedge x_2\wedge x_3\wedge (\neg x_4 )
\wedge\ldots.
\end{equation}

The function $f$ can now be represented in terms of three elementary
logical operations AND, OR, and NOT.  This representation of the 
function is called, in the computer science literature, ``disjunctive
normal form.''\index{disjunctive normal form}
A small number of elementary gates suffice to evaluate
exactly any function of a finite input.  This is an important result
in computer science and allows for arbitrarily complex computations
to be built up out of very simple physical devices.

\subsubsection{Circuits and Complexity}
\index{circuit complexity}

Computers have a few basic components that can perform elementary 
operations on bits or pairs of bits.  A {\sl computation} is a 
finite sequence of such operations (a \emph{circuit}) applied to a 
specified string of input bits.
\index{circuit}
\index{computation}
The complexity of a computation can be represented by 
the complexity of the corresponding circuit.
For a decision problem, a reasonable measure of the difficulty
of the problem is the \emph{size} of the smallest circuit that
computes the corresponding function 
\begin{equation}    
f\colon\lbrace 0,1\rbrace^n \mapsto \lbrace 0,1\rbrace.
\end{equation}
Here, size is measured by the number of elementary operations 
(gates) that make up the circuit used to compute $f$.
If more that one gate is allowed to act at once, then the
\emph{time} it takes to complete the computation can be a measure
of its difficulty.  In this case, the \emph{depth} of the circuit
is the maximum number of time steps required to complete, or the 
maximum length of a directed path from the input to the output of
the circuit.  The \emph{width} of a circuit is the maximum number of
gates that can act at any given timestep.

Note that the size of a circuit discussed above
will, in general, scale with the number of bits, the size, of the input.  
The complexity of the circuit can then be determined by how 
the size of the circuit will scale with the size of the input.
Consider a circuit $C_f$ that evaluates a decision problem
corresponding to the function $f$.  The input to this particular
circuit has $n$ bits.  This circuit is considered to be of
\emph{polynomial size} if the size of the circuit grows no faster
than some polynomial of $n$, or
\begin{equation}
\text{Size}\left( C_f \right) \le \text{Poly}(n).
\end{equation}
Decision problems with circuits of polynomial size are considered
to be ``easy,'' otherwise, they are referred to as ``hard.''
A \emph{complexity class}\index{complexity class} of these problems 
can be defined as ({\bf P} for Polynomial)
\begin{equation}
{\bf P} = \lbrace\text{decision problems with polynomial--sized circuits}
          \rbrace.
\end{equation}
Decision problems in {\bf P} are easy, otherwise, they are hard.

%\mmm{exponential lookup table stuff and introduce NP}



%--------------------------------------------------------------------------------   
\subsection{Quantum Theory of Computation}

The circuit model of classical computation will need to be generalized
for a quantum computer.  The universal gates in these quantum circuits
will need to be implemented as unitary tranformations of quantum
states, and hence will need to be reversible.

\subsubsection{Reversibility}
\index{reversibility}

A reversible computation will evaluate an invertible function
such as
\begin{equation}
f\colon\lbrace 0,1\rbrace^n \to\lbrace 0,1\rbrace^n.
\end{equation}
This computation will need to be able to run in either direction,
obtaining output from input and vice--versa, and so the function
will need to be bijective.  Bijective maps of $\Z_2^n$ to itself
can be represented by permutations of the set.

Note that a non--invertible function
\begin{equation}
f\colon\lbrace 0,1\rbrace^n \to\lbrace 0,1\rbrace^m
\end{equation}
can be made into an invertible function
\begin{equation}
{\tilde f}\colon\lbrace 0,1\rbrace^{n+m} \to\lbrace 0,1\rbrace^{n+m}
\end{equation}
such that
\begin{equation}
{\tilde f}\colon
    \begin{bmatrix}
        \left.
        \begin{matrix}
            x_1\\ 
            x_2\\
            \vdots\\
            x_n
        \end{matrix}\right\rbrace\text{n}\\
        \left.
        \begin{matrix}
            0_{\phantom{i}}\\
            \vdots\\
            0_{\phantom{i}}
        \end{matrix}\right\rbrace\text{m}
    \end{bmatrix}
\mapsto
    \begin{bmatrix}
        \begin{matrix}
            x_1\\ 
            x_2\\
            \vdots\\
            x_n
        \end{matrix}\\
        f_1(x)\\
        \vdots\\
        f_m(x) 
    \end{bmatrix},
\end{equation}
and hence into a reversible computation.

Now, how can this reversible function be made up from basic gates?
Are there {\sl reversible} universal gates?
Classical logic gates are, in general, not reversible.
The trivial gate, which takes an input directly to an output,
as well as the \texttt{NOT} gate are obviously reversible.
\texttt{AND} and \texttt{OR} are not.  However, 
there exist non--trivial reversible gates.
The next simplest is the conrolled--\texttt{NOT}
(\texttt{CNOT}) or the exclusive--\texttt{OR} (\texttt{XOR}) gate
\begin{equation}
\texttt{XOR}\colon (x,y)\mapsto (x, x\oplus y).
\end{equation}
%
\begin{figure}[h]
\begin{center}
\begin{picture}(40,50)
    \put(20,40){\circle*{4}}
    \put(20,10){\circle{6}}
    \put(-20,7){$y$}
    \put(-20,37){$x$}
    \put(50,7){$y\oplus x$}
    \put(50,37){$x$}
    \path(0,10)(40,10)
    \path(0,40)(40,40)
    \path(20,7)(20,40)
\end{picture}
\caption{A controlled--\texttt{NOT} (\texttt{CNOT}) or exclusive--\texttt{OR}
(\texttt{XOR}) gate.}
\label{fig:xor}
\end{center}
\end{figure}
%
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
    \hline
    $x$&$y$&$x\oplus y$\\
    \hline
    0&0&0\\
    0&1&1\\
    1&0&1\\
    1&1&0\\
    \hline
\end{tabular}
\end{center}
\caption{Truth table for an exclusive--\texttt{OR} (\texttt{XOR}) gate.}
\label{tab:xor}
\end{table}
%
This gate flips the second bit when the first is set as shown in 
figure (\ref{fig:xor}) and table (\ref{tab:xor}).  Notice that this
could be used as a copy operation if the second bit ($y$) is initially set
to zero (figure (\ref{fig:xorCopy}))
%
\begin{figure}[h]
\begin{center}
\begin{picture}(40,50)
    \put(20,40){\circle*{4}}
    \put(20,10){\circle{6}}
    \put(-20,7){$0$}
    \put(-20,37){$x$}
    \put(50,7){$x$}
    \put(50,37){$x$}
    \path(0,10)(40,10)
    \path(0,40)(40,40)
    \path(20,7)(20,40)
\end{picture}
\caption{A controlled--\texttt{NOT} (\texttt{CNOT}) gate can be used to perform
a \texttt{COPY}.}
\label{fig:xorCopy}
\end{center}
\end{figure}
%
\begin{equation}
\texttt{XOR}\colon (x,0)\mapsto (x, x).
\end{equation}
      
Perhaps the most useful reversible gate is the
controlled--controlled--\texttt{NOT} (\texttt{CCNOT}) gate
\begin{equation}
\texttt{CCNOT}\colon (x,y,z)\mapsto (x,y, z\oplus xy),
\end{equation}
which flips the third bit only if the first two are 1
and does nothing otherwise.
\begin{figure}[h]
\begin{center}
\begin{picture}(40,80)
    \put(20,70){\circle*{4}}
    \put(20,40){\circle*{4}}
    \put(20,10){\circle{6}}
    \put(-20,7){$z$}
    \put(-20,37){$y$}
    \put(-20,67){$x$}
    \put(50,7){$z\oplus xy$}
    \put(50,37){$y$}
    \put(50,67){$x$}
    \path(0,10)(40,10)
    \path(0,40)(40,40)
    \path(0,70)(40,70)
    \path(20,7)(20,70)
\end{picture}
\caption{A controlled--controlled--\texttt{NOT} (\texttt{CCNOT}) gate}
\end{center}
\end{figure}

The \texttt{CCNOT} gate is also known as the \emph{Toffoli gate},
\index{Toffoli gate}
and, unlike the reversible two--bit gates, is itself a universal gate
for Boolean logic.  A Boolean circuit can be built to compute any
reversible computation using Toffoli gates alone, provided input bits
can be fixed and output bits can be ignored.  For more on this, 
the reader is referred to the literature.  
Preskill\cite{Preskill:98}, for example, addresses this in more detail.

Note that a reversible circuit can simulate a circuit composed of 
irreversible gates.  This can be done efficiently without many
additional memory resources (bits) and without appreciable
slowdown.  Since this can so easily be done, the complexity
of a reversible circuit will essentially be the same as the
irreversible circuit.

\subsubsection{Quantum Circuits}

A classical computer has ``bits,'' while a quantum computer will have
\emph{quantum bits}, or ``qubits.''
\index{quantum bit}\index{qubit}
A quantum bit will be the state of a two--state quantum system.
Say, for instance for some spin system,
\begin{equation}
\begin{split}
    \ket{1} =& \,\ket{\uparrow}\\
    \ket{0} =& \,\ket{\downarrow},
\end{split}
\end{equation}
More will be discussed about the actual physical
implementation of these qubits later.

Sets of bits, will be tensor product states of qubits.  
\begin{equation}
\ket{0110\ldots} = \ket{0}\otimes
             \ket{1}\otimes
             \ket{1}\otimes
             \ket{0}\otimes\ldots.
\end{equation}
It is assumed, at any time during a computation, that the Hilbert space
for the entire quantum computer will factor
into tensor products of smaller dimensional Hilbert spaces.  
For the most part, it is assumed these will be two--dimensional Hilbert 
spaces in order to more closely resemble classical {\sl binary} computations.  
However, notice that nothing precludes
working with {\sl qutrits} or, in general, {\sl qudits} (d--state
systems) as the basic unit of computation.

A classical computer has circuits, or sets of gates, that act on 
sets of bits, or registers.
\index{register}
Likewise, the quantum computer will have \emph{quantum circuits},
\index{quantum circuit} which consist of sets of \emph{quantum gates}
\index{quantum gate} which act on sets of qubits.  Each quantum
gate will consist of a unitary transformation that acts on a fixed
number of qubits.  

Each of the reversible classical gates described above have quantum
analogues.  In particular, the quantum version of the Toffoli gate,
called the \emph{Deutsch gate}\index{Deutsch gate} (shown in figure
(\ref{fig:deutschGate}))
\begin{figure}[h]
\begin{center}
\begin{picture}(40,80)
    \put(20,70){\circle*{4}}
    \put(20,40){\circle*{4}}
    \put(-20,7){$\ket{z}$}
    \put(-20,37){$\ket{y}$}
    \put(-20,67){$\ket{x}$}
    \put(50,7){$f({\bf R})\ket{z}$}
%    \put(50,7){$\begin{cases}
%                    {\bf R}\ket{z}& x\wedge y=1\\
%                    \ket{z}& \text{otherwise}
%                \end{cases}$}
    \put(50,37){$\ket{y}$}
    \put(50,67){$\ket{x}$}
    \path(0,10)(10,10)
    \path(30,10)(40,10)
    \put(10,0){\framebox(20,20){\bf{$R$}}}
    \path(0,40)(40,40)
    \path(0,70)(40,70)
    \path(20,20)(20,70)
\end{picture}
\caption{The Deutsch gate is the quantum analogue of the Toffoli gate.  Like it's 
classical counterpart, it too is a universal gate.}
\label{fig:deutschGate}
\end{center}
\end{figure}
will conditionally apply a rotation ${\bf R}$ to the third qubit by
\begin{equation}
f(R) = \begin{cases}
            R,&xy=1\\
            1,&\text{otherwise}.
       \end{cases}
\end{equation}
The rotation applied
\begin{equation}
\begin{split}
R = -iR_x(\theta) =& (-i)\exp \left( i\frac{\theta}{2}\sigma_x \right)\\
  =& (-i)\left( \cos\frac{\theta}{2} + i\sigma_x\sin\frac{\theta}{2} \right)
\end{split}
\end{equation}
is a rotation about the $x$ axis by some angle $\theta$.
This gate is a universal gate for quantum circuits.  

A particularly useful two--qubit quantum gate is a 
controlled--${\bf U}$ gate (figure (\ref{fig:controlledU})).  
\begin{figure}[h]
\begin{center}
\begin{picture}(40,80)
    \put(20,40){\circle*{4}}
    \put(-20,7){$\ket{y}$}
    \put(-20,37){$\ket{x}$}
    \put(50,7){$f({\bf U})\ket{y}$}
    \put(50,37){$\ket{x}$}
    \path(0,10)(10,10)
    \path(30,10)(40,10)
    \put(10,0){\framebox(20,20){\bf{$U$}}}
    \path(0,40)(40,40)
    \path(20,20)(20,40)
\end{picture}
\caption{The controlled--${\bf U}$ gate.}
\label{fig:controlledU}
\end{center}
\end{figure}
If the first qubit has value 1,
this gate will apply the transformation ${\bf U}$ to the second qubit,
otherwise, no action is taken.  This quantum gate will be used in almost
all quantum algorithms in one form or another.

A computation on a quantum computer will start with a register of quantum
bits in some initial configuration.  The circuit of quantum gates will act 
on these qubits to perform whatever computations are necessary.  Finally,
a Von Neumann measurement is performed on the register of qubits, projecting
each onto some measurement basis $\lbrace\ket{0},\ket{1}\rbrace$.
The outcome of this measurement is the result of the computation.

Before more is discussed about quantum algorithms and the actual
computations involved, there are still a few more basic tools
to be developed.  Practically every computation involves the use of
at least one Hadamaard transformation.

\subsubsection{The Hadamaard Transformation}
\label{sssec:Hadamaard}
\index{Hadamaard transformation}

The one--dimensional Hadamaard transformation takes a quantum bit into the
superposition given by
\begin{equation}
\begin{split}
\ket{0}\quad\mapsto&\quad\frac{1}{\sqrt{2}}\left(\ket{0} +\ket{1}\right)\\
\ket{1}\quad\mapsto&\quad\frac{1}{\sqrt{2}}\left(\ket{0} -\ket{1}\right).
\end{split}
\end{equation}
This transformation has a matrix realization given by
\begin{equation}
H_1 
%\left[\begin{matrix}\ket{0}\\ \ket{1}\end{matrix}\right]
= \frac{1}{\sqrt{2}}
\left[\begin{matrix}1&1\\ 1&-1\end{matrix}\right].
%\left[\begin{matrix}\ket{0}\\ \ket{1}\end{matrix}\right].
\end{equation}
%
\begin{figure}[h]
\begin{center}
\begin{picture}(50,60)
    \put(20,0){\framebox(20,50){\bf{$H$}}}
    \put(-20,7){$\ket{1}$}
    \put(-20,37){$\ket{0}$}
    \path(0,10)(20,10)
    \path(40,10)(60,10)
    \path(0,40)(20,40)
    \path(40,40)(60,40)
    \put(65,7){$\frac{1}{\sqrt{2}}\left(\ket{0}-\ket{1}\right)$}
    \put(65,37){$\frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right)$}
\end{picture}
\caption{A quantum circuit applying a Hadamaard transformation to two qubits.}
\end{center}
\end{figure}

The version of the Hadamaard transformation that sees the most use is
the $N$--dimensional Hadamaard transformation defined as the $N$--fold
tensor product of one--dimensional Hadamaard transformations
\begin{equation}
H= H_N= \bigotimes^N H_1.
\end{equation}
This is often used as the first step in many quantum algorithms.
First, start with the \emph{zero register}
\index{zero register}
\begin{equation}
\ket{\bf 0}=\ket{0\ldots 0} = \bigotimes^N\ket{0},
\end{equation} and then act
\begin{equation}
\begin{split}
H\ket{\bf 0} =& H_N\ket{0\ldots 0}\\
=& \bigotimes^N H_1\ket{0}\\
=& \bigotimes^N \frac{1}{\sqrt{2}}\left(\ket{0} +\ket{1}\right)\\
=& \frac{1}{\sqrt{2^N}}\biggl\lbrace \ket{0\ldots 0} + \ket{0\ldots 01} +
\quad\cdots\quad + \ket{1\ldots 1}\biggr\rbrace.
\end{split}
\label{e:hadamaard}
\end{equation}
Now, each of the kets on the bottom--RHS of equation (\ref{e:hadamaard})
can be thought of as just a number expressed in binary. \ie,
\begin{equation}
\begin{split}
H\ket{\bf 0} =& \frac{1}{\sqrt{2^N}}\biggl\lbrace 
\underset{0}{\underbrace{\ket{0\ldots 0}}}
+ \underset{1}{\underbrace{\ket{0\ldots 01}}} + \cdots 
+ \underset{2^N-1}{\underbrace{\ket{1\ldots 1}}}\biggr\rbrace \\
=& \frac{1}{\sqrt{2^N}}\sum_{x=0}^{2^N-1} \ket{x}.
\end{split}
\end{equation}
This will be useful in function evaluation. 
\ie, Consider a function such as $f\colon\lbrace 0,1\rbrace^N\to\lbrace 
0,1\rbrace$.
Since the following are equivalent
\begin{equation}
\begin{split}
(0,0,0,\ldots,1,0)&\mapsto f(0,0,0,\ldots,1,0)\\
\underset{2}{\underbrace{(000\ldots 10)}}&
\mapsto f\underset{2}{\underbrace{(000\ldots 10)}}\\
(2)&\mapsto f(2),
\end{split}
\end{equation}
%Instead of thinking of this function as 
%\begin{equation}
%(0,0,0,\ldots,1,0)\mapsto f(0,0,0,\ldots,1,0),
%\end{equation}
one can simply think of this function as $x\mapsto f(x)$.
So, as a first step, the Hadamaard transformation acts on a quantum 
zero register, preparing it in a superposition of all possible values 
of $x$
\begin{equation}
H\ket{\bf 0} = \frac{1}{\sqrt{2^N}}\sum_{x=0}^{2^N-1} \ket{x}.
\end{equation}

A Hadamaard transformation can also act on a {\sl general} state 
$\ket{x}=\ket{x_1\ldots x_N}$
(not necessarily all 0's), which can be written as
\begin{equation}
\begin{split}
H\colon\ket{x}\quad\mapsto\quad&
\bigotimes_{i=1}^N 
H_1\ket{x_i}\\
\quad\mapsto\quad&
\bigotimes_{i=1}^N 
\frac{1}{\sqrt{2}} \left( \ket{0} + (-1)^{x_i}\ket{1} \right)\\
\quad\mapsto\quad&
\bigotimes_{i=1}^N 
\left(\frac{1}{\sqrt{2}} \sum_{y_i\in\lbrace 0,1\rbrace} 
(-1)^{x_iy_i}\ket{y_i}\right)\\
\quad\mapsto\quad&
\frac{1}{\sqrt{2^N}} \sum_{y=0}^{2^N-1} (-1)^{x\cdot y}\ket{y},
\end{split}
\label{e:generalHadamaard}
\end{equation}
where $x\cdot y$ denotes a dot product over $\left(\Z_2\right)^N$, or
simply a binary dot product.  Note that the final form of equation
(\ref{e:generalHadamaard}) is actually the Fourier transform of $\ket{x}$
over $\left(\Z_2\right)^N$.



%%--------------------------------------------------------------------------------   
%%--------------------------------------------------------------------------------   
%\section{Quantum Algorithms}
%\label{sec:quantCompAlgs}
%
%Grover\cite{Grover:96a}\dots did some stuff!
%\mmm{maybe leave for next chapter?}

%%--------------------------------------------------------------------------------   
%%--------------------------------------------------------------------------------   
%\section{Quantum Cryptography}
%
%\subsubsection{QKDs \& proofs}

%--------------------------------------------------------------------------------   
%--------------------------------------------------------------------------------   
\section{Quantum Error Correction}

\subsubsection{ECCs}
\subsubsection{Code bdles?}

%%--------------------------------------------------------------------------------   
%%--------------------------------------------------------------------------------   
%\section{Quantum Hardware}
